<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"/>
<title>For Surbhi ❤️</title>
<style>
  @import url('https://fonts.googleapis.com/css2?family=Dancing+Script:wght@700&family=Fira+Code:wght@500&display=swap');

  html, body {
    margin: 0;
    padding: 0;
    background: #000;
    overflow: hidden;
    touch-action: none;
  }

  canvas {
    display: block;
    position: absolute;
    top: 0;
    left: 0;
    z-index: 1;
  }

  /* Container for the text at the bottom */
  #text-container {
    position: absolute;
    bottom: 10%;
    left: 0;
    width: 100%;
    text-align: center;
    z-index: 2;
    pointer-events: none;
  }

  /* Stylish Glowing Text */
  #typewriter {
    font-family: 'Dancing Script', cursive; /* More romantic font */
    font-size: clamp(28px, 8vw, 50px);
    color: #ff4d6d;
    text-shadow: 0 0 10px #ff4d6d, 0 0 20px #ff4d6d, 0 0 40px #ff0040;
    display: inline-block;
    white-space: nowrap;
  }

  .cursor {
    display: inline-block;
    width: 3px;
    height: 1em;
    background-color: #ff4d6d;
    margin-left: 5px;
    vertical-align: middle;
    animation: blink 1s infinite;
    box-shadow: 0 0 10px #ff4d6d;
  }

  @keyframes blink {
    0%, 100% { opacity: 1; }
    50% { opacity: 0; }
  }

  #start {
    position: fixed;
    inset: 0;
    background: radial-gradient(circle, #1a0005 0%, #000 100%);
    color: #ff4d6d;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    font-family: 'Fira Code', monospace;
    z-index: 10;
    cursor: pointer;
    transition: opacity 1.5s;
  }

  .heart-beat { animation: beat 1.2s infinite ease-in-out; }
  @keyframes beat {
    0%, 100% { transform: scale(1); }
    50% { transform: scale(1.3); text-shadow: 0 0 20px #ff0040; }
  }
</style>
</head>

<body>

<div id="start">
  <div class="heart-beat" style="font-size: 60px;">❤️</div>
  <p style="margin-top:20px; letter-spacing: 2px;">TAP TO FEEL THE MAGIC</p>
</div>

<canvas id="c"></canvas>

<div id="text-container">
  <span id="typewriter"></span><span class="cursor"></span>
</div>

<audio id="music" loop>
  <source src="music.mp3" type="audio/mpeg">
</audio>

<script>
const canvas = document.getElementById("c");
const ctx = canvas.getContext("2d");

function resize(){
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
}
resize();
window.addEventListener("resize", resize);

let turtle = { x: 0, y: 0, a: -90 };
let queue = [];
const message = "Surbhi ❤️ love you";
let textIndex = 0;

// Particle system for floating hearts
let particles = [];
class HeartParticle {
    constructor() {
        this.reset();
    }
    reset() {
        this.x = Math.random() * canvas.width;
        this.y = canvas.height + 20;
        this.size = Math.random() * 15 + 5;
        this.speed = Math.random() * 1 + 0.5;
        this.opacity = Math.random() * 0.5 + 0.2;
    }
    update() {
        this.y -= this.speed;
        if (this.y < -20) this.reset();
    }
    draw() {
        ctx.fillStyle = `rgba(255, 77, 109, ${this.opacity})`;
        ctx.font = `${this.size}px serif`;
        ctx.fillText("❤️", this.x, this.y);
    }
}

function initParticles() {
    for(let i=0; i<30; i++) particles.push(new HeartParticle());
}

function resetTurtle() {
  turtle = { x: canvas.width / 2, y: canvas.height * 0.82, a: -90 };
}

function f(dist, color, width) {
  queue.push(() => {
    ctx.beginPath();
    ctx.strokeStyle = color;
    ctx.lineWidth = width;
    ctx.lineCap = "round";
    ctx.shadowBlur = width > 2 ? 15 : 5;
    ctx.shadowColor = color;
    ctx.moveTo(turtle.x, turtle.y);
    
    let rad = turtle.a * (Math.PI / 180);
    let nx = turtle.x + Math.cos(rad) * dist;
    let ny = turtle.y + Math.sin(rad) * dist;
    
    ctx.lineTo(nx, ny);
    ctx.stroke();
    ctx.shadowBlur = 0;
    
    turtle.x = nx;
    turtle.y = ny;
  });
}

function l(angle) { queue.push(() => turtle.a -= angle); }
function r(angle) { queue.push(() => turtle.a += angle); }

function dot() {
  queue.push(() => {
    ctx.fillStyle = "#ff0040";
    ctx.shadowBlur = 20;
    ctx.shadowColor = "#ff0040";
    ctx.beginPath();
    ctx.arc(turtle.x, turtle.y, 4, 0, Math.PI * 2);
    ctx.fill();
    ctx.shadowBlur = 0;
  });
}

function tree(len, depth) {
  if (len < 12 || depth > 10) {
    dot();
    return;
  }
  let width = Math.max(1, len / 12);
  let color = `hsl(${340 + depth * 3}, 100%, ${60 + depth * 2}%)`;
  f(len, color, width);
  let s = null;
  queue.push(() => { s = { ...turtle }; });
  l(25); tree(len * 0.75, depth + 1);
  queue.push(() => { turtle = { ...s }; });
  r(50); tree(len * 0.75, depth + 1);
  queue.push(() => { turtle = { ...s }; });
}

function typeWriter() {
  if (textIndex < message.length) {
    document.getElementById("typewriter").innerHTML += message.charAt(textIndex);
    textIndex++;
    setTimeout(typeWriter, 150);
  }
}

function animate() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  
  // Update and draw floating hearts
  particles.forEach(p => { p.update(); p.draw(); });

  // Draw tree branches from queue (multiple steps for speed)
  for(let i=0; i<4; i++) {
      if(queue.length > 0) queue.shift()();
  }
  
  // Re-draw already drawn parts of the tree
  // (In a real turtle app we'd use a second canvas for the tree to avoid clearing it)
  // For simplicity here, we use the persistent drawing of the tree 
  // by NOT clearing the whole canvas every frame, but we need clear for particles.
  // Fix: Draw particles on bottom, tree on top.
  
  requestAnimationFrame(animate);
}

// Separate permanent canvas for tree to keep it while background hearts move
const treeCanvas = document.createElement('canvas');
const treeCtx = treeCanvas.getContext('2d');
function resizeTree(){
    treeCanvas.width = window.innerWidth;
    treeCanvas.height = window.innerHeight;
}
resizeTree();

function animateEverything() {
    // 1. Clear main canvas
    ctx.clearRect(0,0,canvas.width, canvas.height);
    
    // 2. Draw floating particles
    particles.forEach(p => { p.update(); p.draw(); });
    
    // 3. Draw tree steps onto the treeCanvas
    for(let i=0; i<6; i++) {
        if(queue.length > 0) {
            let task = queue.shift();
            // Redirect turtle drawing to treeCtx
            let originalCtx = window.ctx; 
            window.ctx = treeCtx;
            task();
            window.ctx = originalCtx;
        }
    }
    
    // 4. Layer the treeCanvas onto the main canvas
    ctx.drawImage(treeCanvas, 0, 0);
    
    requestAnimationFrame(animateEverything);
}

document.getElementById("start").onclick = function() {
  document.getElementById("start").style.opacity = 0;
  setTimeout(() => document.getElementById("start").remove(), 1500);
  document.getElementById("music").play().catch(() => {});
  
  initParticles();
  resetTurtle();
  // Using treeCtx for the actual tree logic inside f() and dot()
  window.ctx = treeCtx; 
  tree(canvas.height * 0.18, 0);
  window.ctx = ctx;
  
  animateEverything();
  setTimeout(typeWriter, 1000);
};
</script>
</body>
</html>
